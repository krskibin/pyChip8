\section{Emulacja}
\subsection{Wirtualizacja, a emulacja}
Pomimo swojej złożoności systemy komputerowe nadal ewoluują, jest to możliwe dzięki dobrze zaprojektowanym interfejsom, które oddzielają poziomy abstrakcji, przez co niepotrzebna jest szczegółowa znajomość implementacji niższego poziomu, ułatwia to w niezależny sposób rozwój warstwy sprzętowej jak i oprogramowania. Niestety ma to swoje ograniczenia, aplikacje, które są dystrybuowane jako skomplikowane pliki binarne zależą od konkretnego interfejsu systemu operacyjnego \cite{James}. Istnieją dwie główne metody, które zapewniają sposób na obejście takich ograniczeń. Pierwsza z nich to wirtualizacja. Jej zadaniem jest ominięcie warstwy sprzętowej lub systemowej i odpowiednie jej zmapowanie na inny system lub architekturę sprzętową. Sam koncept wirtualizacji nie musi wyłącznie odnosić się do poszczególnych podzespołów lub podsystemów, ale do całych maszyn. Wówczas programiści muszą dostarczyć oprogramowanie, które wspiera całą architekturę urządzenia\cite{James, Popek}, tworząc w ten sposób maszynę wirtualną. Dzięki temu omijają oni rzeczywistą kompatybilność urządzeń, jaki i ograniczenia zasobów sprzętowych. Innym podejściem na wyabstrahowanie jednego systemu w drugim jest emulacja, która w swoich założeniach również opiera się na maszynie wirtualnej, ale zamiast dostarczać wirtualne interfejsy jak w przypadku wirtualizacji, symuluje działanie całej architektury urządzenia. Główna różnica polega na tym, że w pierwszym przypadku zestaw instrukcji procesora (\textit{ISA}) gospodarza \cite{James} jest taki sam, lub w większości podobny do tego w maszynie wirtualnej. Niepasujące do zestawu hosta kody procesora są przechwytywane i wykonywane przez oprogramowanie \cite{ROSENTHAL}. Z kolei podczas emulacji implementuje się maszynę wirtualną na komputerze gospodarza, którego zestaw instrukcji jest inny od tego z bazowego sprzętu (gościa). W tym przypadku żadna z instrukcji nie jest bezpośrednio przetwarzana przez procesor gospodarza, tylko interpretowana, za pomocą specjalnego programu (interpretera) \cite{James}. Wyodrębnia on każdy ciąg bitów, następnie odkodowuje i emuluje ich wykonanie. Oprogramowanie hosta, które wykonuje tę interpretacje, naśladując zestaw instrukcji maszyny wirtualnej i jej wirtualną konfigurację sprzętową, jest nazywane emulatorem \cite{ROSENTHAL}. Niestety cały ten proces jest relatywnie wolny. W latach 70, twierdzono nawet, że emulacja nie jest powiązana z tworzeniem maszyny wirtualnej, ponieważ proces ten nie jest wystarczająco wydajny, aby mógł on dostatecznie symulować działanie danego urządzenia \cite{Popek}:
\begin{quotation}
"The second characteristic of a virtual machine monitor is efficiency. It demands that a statistically dominant subset of the virtual processor's instructions be executed directly by the real processor, with no software intervention by the VMM. This statement rules out traditional emulators and complete software interpreters (simulators) from the virtual machine umbrella."
\end{quotation}
Jednak z początkiem lat 90. coraz popularniejsze stawały się komputery oparte na architekturze 32-bitowej, które z łatwością mogły emulować 8-bitowe systemy z końca lat 70.

\subsection{Bity i bajty}
Pomimo swojej złożoności, istotą komputera jest przetwarzanie informacji. To elektryczna maszyna, która może rozpoznać tylko dwa stany napięciowe; brak lub bardzo niskie napięcie i wysokie napięcie, generując przy tym sygnał ciągły (analogowy), który zamieniany jest na sygnał cyfrowy, czyli skwantowany. Przyjęto, że sygnał ten będzie reprezentowany w formie zero-jedynkowej, jeden gdy napięcie jest wysokie i zero gdy jest niskie. Taki system przedstawiania cyfr nazywany jest dwójkowym lub binarnym. Już jedna liczba binarna może przedstawić, w którym z dwóch możliwych stanów jest dany układ, dlatego jest ona uznawana za najmniejszą cząstkę informacji możliwą do przetworzenia przez komputer, dzięki czemu zyskała miano bitu. Inną z podstawowych funkcji komputera jest możliwość przechowywania informacji. Dawniej zdecydowano, że najmniejszą ilością przechowywanych bitów  w jednym adresie komórki pamięci będzie bajt, który z początku nie miał określonej liczby \cite{Petzold}, dopiero później ustalono, że będzie to 8 bitów. Natomiast, bity o określonej długości na których operacje wykonuje procesor nazwano \textit{słowem}. Jeśli słowo tworzą 32 bity, to taki procesor określany jest jako 32-bitowy. Niestety, przy dużej ilości danych generowanych przez komputery ich przedstawianie za pomocą systemu dwójkowego nie jest czytelne dla człowieka. Ze względu na chęć zachowania większej zwięzłości, w literaturze informatycznej, zdecydowano na zapisywanie ich za pomocą systemu szesnastkowego \cite{Petzold}. \\

Użycie systemu szesnastkowego ułatwia identyfikowanie poszczególnych komórek pamięci czy wartości rejestrów. \\Wszystkie instrukcje przetwarzane przez procesor CHIP-8, również są zapisane w takiej formie. Dzięki temu osoby piszące oprogramowanie na tę jednostkę zamiast używać \textit{słów} o długości 16 bitów, mogą z powodzeniem zapisywać je w formie czteroznakowej. Dodatkowo w instrukcji \cite{COSMAC} zastosowano podział na mniejsze jednostki informacji niż bajty. \\

Do reprezentacji 4-bitowej (jeden znak w systemie szesnastkowym) użyto \textit{półbajta} (ang. \textit{nibble}, \textit{nybble}), z czego bity 7-4 nazywane są \textit{młodszymi}, a bity 0-3 \textit{starszymi} \cite{Cowgod}. Aby łatwiej było identyfikować różne rejestry w jednej instrukcji, wprowadzono oznaczenia \textit{x}, dla młodszych bitów pierwszego bajtu kodu procesora i \textit{y} dla starszych bitów drugiego. Z kolei wartość 12-bitowa jest określana jako adres, ponieważ za jej pomocą identyfikuje się komórki pamięci w komputerze. \\

\subsection{Operatory binarne}
Operowanie na informacji przez procesor nie sprowadza się jedynie do prostych działań matematycznych. Jednostka obliczeniowa wykonuje też operacje binarne, które nie tylko służą programistom do manipulacji zmiennymi, ale również wykorzystywane są przez sam procesor do odpowiedniego pozyskiwania i interpretowania instrukcji. Wśród operatorów bitowych dostępnych w większości współczesnych języków programowania można wyróżnić, \textit{jednoargumentowe}, do których należy negacja, reprezentowana najczęściej za pomocą tyldy ("$\sim$"), lub te wieloargumentowe w skład których wchodzą: koniunkcja ("\&"), alternatywa ("|"), alternatywa wykluczająca ("\string^"), przesunięcia bitowe ('>>' lub '<<'). \\

\subsection{Asembler i deasembler}
W związku z tym, że każdy zestaw kodów operacyjnych dla procesorów różni się w zależności od ich architektury i producenta, powstała cała grupa niskopoziomowych języków programowania nazywana \textit{językami asemblera}, w których każda instrukcja jest mnemonikiem\footnote{Posiada ona uproszczoną słowną reprezentacje czynności procesora} kodu procesora. Proces zamiany zrozumiałego dla człowieka kodu na maszynowy jest dokonywany za pomocą specjalnego programu, który nazywany jest \textit{asemblerem}. Instrukcja \textit{COSMAC VIP} \cite{SCHWARZ} nie posiada składni dla języka assemblera, jednak w \textit{Cowgod's Chip-8 Technical Reference} zamieszczone zostały mnemoniczne nazwy poszczególnych instrukcji, które posłużą do nazwania odpowiadających im funkcji w projekcie emulatora. Dobrą praktyką jest tworzenie programów nazywanych deasemblerami, które przetwarzają kod pliku binarnego na ten w postaci mnemonicznej, zrozumiałej dla człowieka. Ich podstawowym celem jest dokładniejsze zrozumienie działania emulowanego urządzenia. Tego typu programy często stanowią podstawę dla pełnoprawnego emulatora. \\

\subsection{Rejestry i stosy}
Rejestry są to pojemniki na dane o niewielkich rozmiarach służące do przetrzymywania krótkotrwałego wyniku operacji, adresów lokacji w pamięci operacyjnej itd. Dostęp do nich, w porównaniu między innymi do pamięci RAM, jest błyskawiczny \cite{Coldwin}. Procesory najczęściej posiadają kilka rodzajów rejestrów, różniące się one zastosowaniem. W projekcie zostały użyte, te ogólnego przeznaczenia, służące głównie do przetrzymywania wyników operacji arytmetyczno-logicznych na liczbach naturalnych i rejestry specjalne w skład których wchodzą rejestry sterujące (sterujące zachowaniem procesora) i rejestry stanu (przechowujące informacje np. o wystąpieniu pewnego rodzaju zdarzenia)~\cite{Coldwin}. \\

Innym z ważnych elementów budowy procesora jest stos, którego zadaniem jest  zapis tymczasowych danych, takich jak argumenty funkcji, zmienne lokalne, adresy powrotów z funkcji itp. Zasada jego działania opiera się na znanej z algorytmiki strukturze danych o tej samej nazwie. Jednostka obliczeniowa za pomocą rejestru nazywanego wskaźnikiem stosu (ang. \textit{stack pointer}) \cite{Coldwin} steruje jego rozmiarem i przy  wykonaniu odpowiedniej instrukcji dodaje lub usuwa wskazywaną wartość inkrementując lub dekrementując przy tym jego wskaźnik. Zasada ta jest określona jako \textit{LIFO}(ang. \textit{First In Last Out})~\cite{Cormen}. Ostatni dodany element do stosu jest, tym, który jako pierwszy zostanie z niego usunięty.

\subsection{Procesor}
Procesor jest jednostką w maszynie odpowiedzialną za wykonywanie podstawowych operacji. Natomiast rejestry można przyrównać do zmiennych w językach programowania. CHIP-8 posiada ich kilka (V0 - VF), można je potraktować
jak zmienne w języku C++:
\begin{lstlisting}[language=c]
unsigned char V0, V1, V2, V3, V4 ... VF;
\end{lstlisting}
Procesory posiadają także program counter (PC), który można potraktować jako znany z języków, wskaźnik:
\begin{lstlisting}[language=c]
unsigned char *pc;
\end{lstlisting}
To jaki ciąg liczb odpowiada danej instrukcji zapisane jest między innymi w dokumentacji technicznej do CHIP-8 \cite{Cowgod}. Dla przykładu, gdy program counter wskazuje na 0x8FC0, to wykonywana jest instrukcja LOAD(VF, VC). Wartość rejestru VF przeniesiona zostaje do rejestru VC, odpowiada to asemblerowej operacji MOV, lub w \textit{języku C}: VF = VC. Gdyby \textit{pointer couter} wskazywał na wartość 0x8FC4, to została by wykonana instrukcja ADD, która w \textit{języku asemblera} , jej odpowiednik w \textit{C} to VF = VF + VC. \\

Kolejną ważną kwestią jest czas wykonywania instrukcji. Realizacja każdego kodu procesora w CHIP-8 mierzona jest za pomocą tak zwanych cykli. We współczesnych jednostkach obliczeniowych zależy ona od ilości wykonywanych instrukcji, natomiast w starszych takich jak \textit{COSMAC-1802} czas ten był z góry określony przez producenta urządzenia \textit{Cowgod}. \\